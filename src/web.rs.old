//! Web æœåŠ¡å™¨æ¨¡å—
//!
//! ä¸º monolith å·¥å…·æä¾›åŸºäº Web çš„ç¿»è¯‘å’Œå†…å®¹å¤„ç†æœåŠ¡

use std::sync::Arc;

#[cfg(feature = "web")]
use axum::{
    extract::{Json as ExtractJson, Path, State},
    http::StatusCode,
    response::{Html, Json},
    routing::{get, post},
    Router,
};

#[cfg(feature = "web")]
use serde::{Deserialize, Serialize};

#[cfg(feature = "web")]
use tokio::task;

#[cfg(feature = "web")]
use tower_http::{cors::CorsLayer, services::ServeDir};

use crate::core::{create_monolithic_document, MonolithError, MonolithOptions};
use crate::session::Session;

#[cfg(feature = "translation")]
use crate::translation::{translate_dom_content, load_translation_config};
#[cfg(feature = "translation")]
use crate::html::{html_to_dom, serialize_document};

#[cfg(feature = "web")]
use crate::redis_cache::{RedisCache, RedisCacheConfig, create_cached_translation};

#[cfg(feature = "web")]
use crate::html_builder::{HtmlBuilder, HtmlBuilderConfig};

/// Web æœåŠ¡å™¨é…ç½®
#[derive(Debug, Clone)]
pub struct WebConfig {
    /// ç»‘å®šåœ°å€
    pub bind_addr: String,
    /// ç«¯å£
    pub port: u16,
    /// é™æ€æ–‡ä»¶ç›®å½•
    pub static_dir: Option<String>,
    /// Redis ç¼“å­˜é…ç½®
    pub redis_config: Option<RedisCacheConfig>,
}

impl Default for WebConfig {
    fn default() -> Self {
        Self {
            bind_addr: "127.0.0.1".to_string(),
            port: 7080,
            static_dir: Some("static".to_string()),
            redis_config: Some(RedisCacheConfig::default()),
        }
    }
}

/// åº”ç”¨çŠ¶æ€
#[cfg(feature = "web")]
#[derive(Clone)]
pub struct AppState {
    pub monolith_options: MonolithOptions,
    pub redis_cache: Option<RedisCache>,
}

/// ç¿»è¯‘è¯·æ±‚
#[cfg(feature = "web")]
#[derive(Deserialize)]
pub struct TranslateRequest {
    pub url: String,
    pub target_lang: Option<String>,
    pub source_lang: Option<String>,
}

/// ç¿»è¯‘å“åº”
#[cfg(feature = "web")]
#[derive(Serialize)]
pub struct TranslateResponse {
    pub original_html: String,
    pub translated_html: String,
    pub title: Option<String>,
    pub url: String,
}

/// å†…å®¹è¯·æ±‚
#[cfg(feature = "web")]
#[derive(Deserialize)]
pub struct ContentRequest {
    pub url: String,
}

/// å†…å®¹å“åº”
#[cfg(feature = "web")]
#[derive(Serialize)]
pub struct ContentResponse {
    pub html: String,
    pub title: Option<String>,
    pub url: String,
}

/// ç¼“å­˜ç»Ÿè®¡å“åº”
#[cfg(feature = "web")]
#[derive(Serialize)]
pub struct CacheStatsResponse {
    pub enabled: bool,
    pub total_keys: usize,
    pub total_size_bytes: usize,
    pub expired_keys: usize,
}

/// ç¼“å­˜æ¸…ç†è¯·æ±‚
#[cfg(feature = "web")]
#[derive(Deserialize)]
pub struct CacheClearRequest {
    pub url: Option<String>,
    pub source_lang: Option<String>,
    pub target_lang: Option<String>,
}

/// ä¹¦ç­¾è„šæœ¬å“åº”
#[cfg(feature = "web")]
#[derive(Serialize)]
pub struct BookmarkletResponse {
    pub bookmarklet_code: String,
    pub installation_guide: String,
    pub example_usage: String,
}

/// åº“åŸŸååˆ†ç±»è¯·æ±‚
#[cfg(feature = "web")]
#[derive(Deserialize)]
pub struct LibraryRequest {
    pub domain: Option<String>,
    pub page: Option<usize>,
    pub limit: Option<usize>,
}

/// åº“åŸŸååˆ†ç±»å“åº”
#[cfg(feature = "web")]
#[derive(Serialize)]
pub struct LibraryResponse {
    pub domains: Vec<LibraryDomain>,
    pub total_domains: usize,
    pub page: usize,
    pub limit: usize,
}

/// åŸŸååº“æ¡ç›®
#[cfg(feature = "web")]
#[derive(Serialize)]
pub struct LibraryDomain {
    pub domain: String,
    pub cache_count: usize,
    pub total_size_bytes: usize,
    pub last_updated: u64,
    pub urls: Vec<LibraryUrl>,
}

/// åŸŸåä¸‹çš„URLæ¡ç›®
#[cfg(feature = "web")]
#[derive(Serialize)]
pub struct LibraryUrl {
    pub url: String,
    pub title: Option<String>,
    pub source_lang: String,
    pub target_lang: String,
    pub created_at: u64,
    pub expires_at: u64,
    pub size_bytes: usize,
}

/// åº“æ“ä½œè¯·æ±‚
#[cfg(feature = "web")]
#[derive(Deserialize)]
pub struct LibraryActionRequest {
    pub action: String, // "delete_domain", "delete_url", "refresh_domain"
    pub domain: Option<String>,
    pub url: Option<String>,
    pub source_lang: Option<String>,
    pub target_lang: Option<String>,
}

/// Web æœåŠ¡å™¨
pub struct WebServer {
    config: WebConfig,
    monolith_options: MonolithOptions,
}

impl WebServer {
    /// åˆ›å»ºæ–°çš„ Web æœåŠ¡å™¨
    pub fn new(config: WebConfig, monolith_options: MonolithOptions) -> Self {
        Self {
            config,
            monolith_options,
        }
    }

    /// å¯åŠ¨ Web æœåŠ¡å™¨
    #[cfg(feature = "web")]
    pub async fn start(&self) -> Result<(), MonolithError> {
        // åˆå§‹åŒ– Redis ç¼“å­˜
        let redis_cache = if let Some(ref redis_config) = self.config.redis_config {
            match RedisCache::new(redis_config.clone()) {
                Ok(cache) => {
                    match cache.test_connection() {
                        Ok(_) => {
                            println!("Redis ç¼“å­˜è¿æ¥æˆåŠŸ: {}", redis_config.url);
                            Some(cache)
                        }
                        Err(e) => {
                            eprintln!("è­¦å‘Š: Redis è¿æ¥å¤±è´¥: {}", e);
                            eprintln!("ç»§ç»­è¿è¡Œï¼Œä½†ç¼“å­˜åŠŸèƒ½å°†ä¸å¯ç”¨");
                            None
                        }
                    }
                }
                Err(e) => {
                    eprintln!("è­¦å‘Š: æ— æ³•åˆå§‹åŒ– Redis ç¼“å­˜: {}", e);
                    eprintln!("ç»§ç»­è¿è¡Œï¼Œä½†ç¼“å­˜åŠŸèƒ½å°†ä¸å¯ç”¨");
                    None
                }
            }
        } else {
            println!("æœªé…ç½® Redis ç¼“å­˜");
            None
        };

        let app_state = Arc::new(AppState {
            monolith_options: self.monolith_options.clone(),
            redis_cache,
        });

        let mut app = Router::new()
            .route("/", get(index))
            .route("/library", get(library_page))
            .route("/bookmarklet", get(bookmarklet_page))
            .route("/website/*url", get(website_bookmarklet))
            .route("/api/translate", post(translate_url))
            .route("/api/content", post(get_content))
            .route("/api/cache/stats", get(get_cache_stats))
            .route("/api/cache/clear", post(clear_cache))
            .route("/api/cache/cleanup", post(cleanup_cache))
            .route("/api/bookmarklet", get(generate_bookmarklet))
            .route("/api/library", get(get_library_data))
            .route("/api/library/action", post(library_action))
            .layer(CorsLayer::permissive())
            .with_state(app_state);

        // æ·»åŠ é™æ€æ–‡ä»¶æœåŠ¡ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
        if let Some(static_dir) = &self.config.static_dir {
            app = app.nest_service("/static", ServeDir::new(static_dir));
        }

        let listener = tokio::net::TcpListener::bind(format!(
            "{}:{}",
            self.config.bind_addr, self.config.port
        ))
        .await
        .map_err(|e| MonolithError::new(&format!("Failed to bind server: {}", e)))?;

        println!(
            "Web server starting at http://{}:{}",
            self.config.bind_addr, self.config.port
        );

        axum::serve(listener, app)
            .await
            .map_err(|e| MonolithError::new(&format!("Server error: {}", e)))?;

        Ok(())
    }

    /// å¯åŠ¨ Web æœåŠ¡å™¨ï¼ˆé web feature ç‰ˆæœ¬ï¼‰
    #[cfg(not(feature = "web"))]
    pub async fn start(&self) -> Result<(), MonolithError> {
        Err(MonolithError::new("Web feature not enabled"))
    }
}

/// ä¸»é¡µå¤„ç†å™¨
#[cfg(feature = "web")]
async fn index() -> Html<String> {
    let config = HtmlBuilderConfig {
        template_dir: "templates".to_string(),
        inline_assets: true, // å†…è”æ‰€æœ‰èµ„æºä»¥ä¾¿å•æ–‡ä»¶éƒ¨ç½²
        asset_base_path: "/".to_string(),
    };
    
    let builder = HtmlBuilder::new(config);
    match builder.build_index_page() {
        Ok(html) => Html(html),
        Err(_) => {
            // å¦‚æœæ„å»ºå¤±è´¥ï¼Œè¿”å›åŸºç¡€ HTML
            let fallback_html = include_str!("../templates/index.html");
            Html(fallback_html.to_string())
        }
    }
}

/// ä¹¦ç­¾è„šæœ¬é¡µé¢å¤„ç†å™¨
#[cfg(feature = "web")]
async fn bookmarklet_page() -> Html<String> {
    // è¯»å–ä¹¦ç­¾è„šæœ¬é¡µé¢æ¨¡æ¿
    let template_content = include_str!("../templates/bookmarklet.html");
    Html(template_content.to_string())
}

/// ä¹¦ç­¾è„šæœ¬è·¯ç”±å¤„ç†å™¨ - å¤„ç† /website/{url} è¯·æ±‚
#[cfg(feature = "web")]
async fn website_bookmarklet(
    Path(url_path): Path<String>,
) -> Html<String> {
    // URL è·¯å¾„å·²ç»ç”± Axum è‡ªåŠ¨è§£ç ï¼Œå»é™¤å‰å¯¼æ–œæ 
    let clean_url = url_path.trim_start_matches('/');
    
    // éªŒè¯ URL æ ¼å¼
    let final_url = if clean_url.starts_with("http://") || clean_url.starts_with("https://") {
        clean_url.to_string()
    } else {
        format!("https://{}", clean_url)
    };
    
    // æ„å»ºå¸¦é¢„åŠ è½½ URL çš„ä¸»é¡µ
    let config = HtmlBuilderConfig {
        template_dir: "templates".to_string(),
        inline_assets: true,
        asset_base_path: "/".to_string(),
    };
    
    let builder = HtmlBuilder::new(config);
    match builder.build_index_page_with_url(&final_url) {
        Ok(html) => Html(html),
        Err(_) => {
            // å¦‚æœæ„å»ºå¤±è´¥ï¼Œè¿”å›å¸¦ JavaScript é¢„åŠ è½½çš„åŸºç¡€ HTML
            let fallback_html = format!(
                r#"<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monolith ç½‘é¡µç¿»è¯‘å™¨ - æ­£åœ¨åŠ è½½</title>
    <style>
        body {{ font-family: Arial, sans-serif; text-align: center; padding: 50px; }}
        .loading {{ color: #667eea; }}
    </style>
</head>
<body>
    <div class="loading">
        <h2>æ­£åœ¨é‡å®šå‘åˆ°ç¿»è¯‘é¡µé¢...</h2>
        <p>ç›®æ ‡ URL: {}</p>
    </div>
    <script>
        // é‡å®šå‘åˆ°ä¸»é¡µå¹¶é¢„åŠ è½½ URL
        const url = "{}";
        const targetUrl = "/?preload_url=" + encodeURIComponent(url);
        window.location.href = targetUrl;
    </script>
</body>
</html>"#,
                final_url, final_url
            );
            Html(fallback_html)
        }
    }
}

/// ç”Ÿæˆä¹¦ç­¾è„šæœ¬
#[cfg(feature = "web")]
async fn generate_bookmarklet(
    State(state): State<Arc<AppState>>,
) -> Result<Json<BookmarkletResponse>, (StatusCode, Json<serde_json::Value>)> {
    // è·å–å½“å‰æœåŠ¡å™¨åœ°å€ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦ä»è¯·æ±‚å¤´è·å–ï¼‰
    let server_url = "http://localhost:7080"; // å¯ä»¥ä»é…ç½®ä¸­è·å–
    
    let bookmarklet_code = format!(
        r#"javascript:(function(){{
    var url = encodeURIComponent(window.location.href);
    var targetUrl = '{}/website/' + url;
    window.open(targetUrl, '_blank');
}})();"#,
        server_url
    );
    
    let installation_guide = r#"
## ä¹¦ç­¾è„šæœ¬å®‰è£…æŒ‡å—

### Chrome/Edge æµè§ˆå™¨:
1. å³é”®ç‚¹å‡»ä¹¦ç­¾æ ï¼Œé€‰æ‹©"æ·»åŠ é¡µé¢"
2. åç§°å¡«å†™: "ç¿»è¯‘å½“å‰é¡µé¢"
3. ç½‘å€å¡«å†™ä¸‹æ–¹çš„ä¹¦ç­¾è„šæœ¬ä»£ç 
4. ç‚¹å‡»ä¿å­˜

### Firefox æµè§ˆå™¨:
1. å³é”®ç‚¹å‡»ä¹¦ç­¾æ ï¼Œé€‰æ‹©"æ–°ä¹¦ç­¾"
2. åç§°å¡«å†™: "ç¿»è¯‘å½“å‰é¡µé¢"
3. ä½ç½®å¡«å†™ä¸‹æ–¹çš„ä¹¦ç­¾è„šæœ¬ä»£ç 
4. ç‚¹å‡»æ·»åŠ 

### Safari æµè§ˆå™¨:
1. å°†ä¸‹æ–¹ä»£ç å¤åˆ¶åˆ°å‰ªè´´æ¿
2. æ·»åŠ ä»»æ„é¡µé¢ä¸ºä¹¦ç­¾
3. ç¼–è¾‘ä¹¦ç­¾ï¼Œå°† URL æ›¿æ¢ä¸ºä¹¦ç­¾è„šæœ¬ä»£ç 
"#.to_string();
    
    let example_usage = r#"
## ä½¿ç”¨æ–¹æ³•

1. åœ¨ä»»æ„ç½‘é¡µä¸Šç‚¹å‡»"ç¿»è¯‘å½“å‰é¡µé¢"ä¹¦ç­¾
2. ç³»ç»Ÿä¼šåœ¨æ–°æ ‡ç­¾é¡µä¸­æ‰“å¼€ç¿»è¯‘ç•Œé¢
3. å½“å‰é¡µé¢çš„ URL ä¼šè‡ªåŠ¨åŠ è½½å¹¶å¼€å§‹ç¿»è¯‘
4. æ”¯æŒåŸæ–‡/è¯‘æ–‡/åŒè¯­å¯¹ç…§æ¨¡å¼åˆ‡æ¢

## æŠ€æœ¯è¯´æ˜

- ä¹¦ç­¾è„šæœ¬ä¼šè·å–å½“å‰é¡µé¢çš„ URL
- è‡ªåŠ¨è·³è½¬åˆ° Monolith ç¿»è¯‘æœåŠ¡
- æ— éœ€æ‰‹åŠ¨å¤åˆ¶ç²˜è´´ URL
- æ”¯æŒæ‰€æœ‰ä¸»æµæµè§ˆå™¨
"#.to_string();
    
    let response = BookmarkletResponse {
        bookmarklet_code,
        installation_guide,
        example_usage,
    };
    
    Ok(Json(response))
}

/// ç¿»è¯‘ URL å¤„ç†å™¨
#[cfg(feature = "web")]
async fn translate_url(
    State(state): State<Arc<AppState>>,
    ExtractJson(request): ExtractJson<TranslateRequest>,
) -> Result<Json<TranslateResponse>, (StatusCode, Json<serde_json::Value>)> {
    let url = request.url.clone();
    let target_lang = request.target_lang.unwrap_or_else(|| "zh".to_string());
    let source_lang = request.source_lang.unwrap_or_else(|| "auto".to_string());

    // æ£€æŸ¥ç¼“å­˜
    if let Some(ref cache) = state.redis_cache {
        if let Ok(Some(cached)) = cache.get(&url, &source_lang, &target_lang) {
            let response = TranslateResponse {
                original_html: cached.original_html,
                translated_html: cached.translated_html,
                title: cached.title,
                url: cached.url,
            };
            return Ok(Json(response));
        }
    }

    // å…‹éš†é€‰é¡¹ç”¨äºå¹¶è¡Œå¤„ç†
    let options_original = state.monolith_options.clone();
    let options_translated = state.monolith_options.clone();

    // å¹¶è¡Œå¤„ç†åŸæ–‡å’Œè¯‘æ–‡
    let original_future = {
        let url = url.clone();
        let options = options_original;
        task::spawn_blocking(move || {
            let session = Session::new(None, None, options);
            create_monolithic_document(session, url)
        })
    };

    let translated_future = {
        let url = url.clone();
        let options = options_translated;
        let target_lang = target_lang.clone();
        task::spawn_blocking(move || -> Result<(Vec<u8>, Option<String>), MonolithError> {
            // å…ˆè·å–åŸå§‹å†…å®¹
            let session = Session::new(None, None, options.clone());
            let original_result = create_monolithic_document(session, url.clone())?;

            // å¦‚æœå¯ç”¨äº†ç¿»è¯‘åŠŸèƒ½ï¼Œè¿›è¡Œç¿»è¯‘
            #[cfg(feature = "translation")]
            {
                let (original_data, title) = original_result;
                let dom = html_to_dom(&original_data, url);
                
                // åŠ è½½ç¿»è¯‘é…ç½®ï¼Œä»é…ç½®æ–‡ä»¶åŠ è½½ API URL
                let translation_config = load_translation_config(&target_lang, None);
                
                // ç¿»è¯‘éœ€è¦åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­è¿è¡Œï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
                // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œæ‚¨å¯èƒ½éœ€è¦ä½¿ç”¨å¼‚æ­¥ç¿»è¯‘æˆ–è€…åŒæ­¥åŒ…è£…
                let translated_dom = tokio::runtime::Handle::current()
                    .block_on(translate_dom_content(dom, &target_lang, Some(&translation_config.deeplx_api_url)))
                    .map_err(|e| MonolithError::new(&format!("Translation error: {}", e)))?;
                
                let translated_data = serialize_document(translated_dom, "UTF-8".to_string(), &options);
                Ok((translated_data, title))
            }
            
            #[cfg(not(feature = "translation"))]
            Ok(original_result)
        })
    };

    // ç­‰å¾…ä¸¤ä¸ªä»»åŠ¡å®Œæˆ
    let (original_result, translated_result) = match tokio::try_join!(original_future, translated_future) {
        Ok((original, translated)) => (original, translated),
        Err(e) => {
            return Err((
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(serde_json::json!({
                    "error": true,
                    "message": format!("Task execution error: {}", e)
                }))
            ));
        }
    };

    let (original_data, original_title) = match original_result {
        Ok(result) => result,
        Err(e) => {
            return Err((
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(serde_json::json!({
                    "error": true,
                    "message": format!("Failed to process original: {}", e)
                }))
            ));
        }
    };

    let (translated_data, translated_title) = match translated_result {
        Ok(result) => result,
        Err(e) => {
            return Err((
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(serde_json::json!({
                    "error": true,
                    "message": format!("Failed to process translation: {}", e)
                }))
            ));
        }
    };

    let original_html = String::from_utf8_lossy(&original_data).to_string();
    let translated_html = String::from_utf8_lossy(&translated_data).to_string();

    // ä½¿ç”¨æ ‡é¢˜
    let title = translated_title.or(original_title);

    // ç¼“å­˜ç»“æœ
    if let Some(ref cache) = state.redis_cache {
        let cached_translation = create_cached_translation(
            url,
            original_html.clone(),
            translated_html.clone(),
            title.clone(),
            source_lang,
            target_lang,
            None, // ä½¿ç”¨é»˜è®¤ TTL
        );
        
        if let Err(e) = cache.set(&cached_translation) {
            eprintln!("è­¦å‘Š: ç¼“å­˜å­˜å‚¨å¤±è´¥: {}", e);
        }
    }

    let response = TranslateResponse {
        original_html,
        translated_html,
        title,
        url: request.url,
    };

    Ok(Json(response))
}

/// è·å–å†…å®¹å¤„ç†å™¨
#[cfg(feature = "web")]
async fn get_content(
    State(state): State<Arc<AppState>>,
    ExtractJson(request): ExtractJson<ContentRequest>,
) -> Result<Json<ContentResponse>, (StatusCode, Json<serde_json::Value>)> {
    let url = request.url.clone();
    let options = state.monolith_options.clone();

    let (data, title) = task::spawn_blocking(move || {
        let session = Session::new(None, None, options);
        create_monolithic_document(session, url)
    })
    .await
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(serde_json::json!({
                "error": true,
                "message": format!("Task execution error: {}", e)
            }))
        )
    })?
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(serde_json::json!({
                "error": true,
                "message": format!("Failed to process content: {}", e)
            }))
        )
    })?;

    let html = String::from_utf8_lossy(&data).to_string();

    let response = ContentResponse {
        html,
        title,
        url: request.url,
    };

    Ok(Json(response))
}

/// ä» HTML ä¸­æå–æ ‡é¢˜
fn extract_title(html: &str) -> Option<String> {
    // ç®€å•çš„æ ‡é¢˜æå–ï¼Œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼
    use regex::Regex;
    
    let re = Regex::new(r"<title[^>]*>([^<]+)</title>").ok()?;
    let caps = re.captures(html)?;
    let title = caps.get(1)?.as_str().trim();
    
    if title.is_empty() {
        None
    } else {
        Some(title.to_string())
    }
}

/// è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
#[cfg(feature = "web")]
async fn get_cache_stats(
    State(state): State<Arc<AppState>>,
) -> Result<Json<CacheStatsResponse>, (StatusCode, Json<serde_json::Value>)> {
    if let Some(ref cache) = state.redis_cache {
        match cache.get_stats() {
            Ok(stats) => {
                let response = CacheStatsResponse {
                    enabled: true,
                    total_keys: stats.total_keys,
                    total_size_bytes: stats.total_size_bytes,
                    expired_keys: stats.expired_keys,
                };
                Ok(Json(response))
            }
            Err(e) => {
                Err((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(serde_json::json!({
                        "error": true,
                        "message": format!("è·å–ç¼“å­˜ç»Ÿè®¡å¤±è´¥: {}", e)
                    }))
                ))
            }
        }
    } else {
        let response = CacheStatsResponse {
            enabled: false,
            total_keys: 0,
            total_size_bytes: 0,
            expired_keys: 0,
        };
        Ok(Json(response))
    }
}

/// æ¸…ç†ç¼“å­˜
#[cfg(feature = "web")]
async fn clear_cache(
    State(state): State<Arc<AppState>>,
    ExtractJson(request): ExtractJson<CacheClearRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<serde_json::Value>)> {
    if let Some(ref cache) = state.redis_cache {
        let result = if let (Some(url), Some(source_lang), Some(target_lang)) = 
            (request.url, request.source_lang, request.target_lang) {
            // æ¸…ç†ç‰¹å®šç¼“å­˜æ¡ç›®
            cache.delete(&url, &source_lang, &target_lang)
                .map(|deleted| if deleted { 1 } else { 0 })
        } else {
            // æ¸…ç†æ‰€æœ‰ç¼“å­˜
            cache.clear_all()
        };

        match result {
            Ok(deleted_count) => {
                Ok(Json(serde_json::json!({
                    "success": true,
                    "message": format!("æˆåŠŸæ¸…ç† {} ä¸ªç¼“å­˜æ¡ç›®", deleted_count),
                    "deleted_count": deleted_count
                })))
            }
            Err(e) => {
                Err((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(serde_json::json!({
                        "error": true,
                        "message": format!("æ¸…ç†ç¼“å­˜å¤±è´¥: {}", e)
                    }))
                ))
            }
        }
    } else {
        Ok(Json(serde_json::json!({
            "success": false,
            "message": "ç¼“å­˜æœªå¯ç”¨"
        })))
    }
}

/// æ¸…ç†è¿‡æœŸç¼“å­˜
#[cfg(feature = "web")]
async fn cleanup_cache(
    State(state): State<Arc<AppState>>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<serde_json::Value>)> {
    if let Some(ref cache) = state.redis_cache {
        match cache.cleanup_expired() {
            Ok(deleted_count) => {
                Ok(Json(serde_json::json!({
                    "success": true,
                    "message": format!("æˆåŠŸæ¸…ç† {} ä¸ªè¿‡æœŸç¼“å­˜æ¡ç›®", deleted_count),
                    "deleted_count": deleted_count
                })))
            }
            Err(e) => {
                Err((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(serde_json::json!({
                        "error": true,
                        "message": format!("æ¸…ç†è¿‡æœŸç¼“å­˜å¤±è´¥: {}", e)
                    }))
                ))
            }
        }
    } else {
        Ok(Json(serde_json::json!({
            "success": false,
            "message": "ç¼“å­˜æœªå¯ç”¨"
        })))
    }
}

/// é web feature çš„å ä½å‡½æ•°
#[cfg(not(feature = "web"))]
async fn index() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

#[cfg(not(feature = "web"))]
async fn translate_url() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

#[cfg(not(feature = "web"))]
async fn get_content() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

#[cfg(not(feature = "web"))]
async fn get_cache_stats() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

#[cfg(not(feature = "web"))]
async fn clear_cache() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

#[cfg(not(feature = "web"))]
async fn cleanup_cache() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

/// åº“ç®¡ç†é¡µé¢å¤„ç†å™¨
#[cfg(feature = "web")]
async fn library_page() -> Html<String> {
    let library_html = r#"<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monolith ç¿»è¯‘åº“</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f5f5; }
        .header { background: white; padding: 1rem; border-bottom: 1px solid #e1e5e9; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .header h1 { color: #333; }
        .nav { display: flex; gap: 1rem; margin-top: 1rem; }
        .nav-btn { padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; text-decoration: none; }
        .nav-btn:hover { background: #5a6fd8; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
        .domain-card { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 1rem; overflow: hidden; }
        .domain-header { padding: 1rem; background: #f8f9fa; border-bottom: 1px solid #e1e5e9; display: flex; justify-content: space-between; align-items: center; }
        .domain-name { font-weight: 600; color: #333; }
        .domain-stats { color: #666; font-size: 0.9rem; }
        .domain-actions { display: flex; gap: 0.5rem; }
        .btn { padding: 0.25rem 0.75rem; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.8rem; }
        .btn-danger { background: #f56565; color: white; border-color: #f56565; }
        .btn-info { background: #4299e1; color: white; border-color: #4299e1; }
        .url-list { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .url-list.expanded { max-height: 500px; }
        .url-item { padding: 1rem; border-bottom: 1px solid #f1f1f1; display: flex; justify-content: space-between; align-items: center; }
        .url-info { flex: 1; cursor: pointer; transition: background-color 0.2s ease; padding: 0.5rem; border-radius: 4px; margin: -0.5rem; }
        .url-info:hover { background-color: #f8f9fa; }
        .url-title { font-weight: 500; color: #333; margin-bottom: 0.25rem; }
        .url-link { color: #667eea; text-decoration: none; font-size: 0.9rem; margin-bottom: 0.25rem; display: block; }
        .url-link:hover { text-decoration: underline; }
        .url-meta { font-size: 0.8rem; color: #666; }
        .url-actions { display: flex; gap: 0.5rem; align-items: center; }
        .cache-status { display: inline-block; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.7rem; font-weight: 500; margin-left: 0.5rem; }
        .cache-status.fresh { background: #c6f6d5; color: #22543d; }
        .cache-status.expired { background: #fed7d7; color: #c53030; }
        .cache-status.expiring { background: #fef5e7; color: #c05621; }
        .url-preview { display: none; position: absolute; background: white; border: 1px solid #e1e5e9; border-radius: 8px; padding: 1rem; box-shadow: 0 4px 16px rgba(0,0,0,0.1); z-index: 1000; max-width: 400px; }
        .loading { text-align: center; padding: 2rem; color: #666; }
        .error { background: #fed7d7; color: #c53030; padding: 1rem; border-radius: 4px; margin-bottom: 1rem; }
    </style>
</head>
<body>
    <header class="header">
        <h1>Monolith ç¿»è¯‘åº“</h1>
        <nav class="nav">
            <a href="/" class="nav-btn">è¿”å›é¦–é¡µ</a>
            <button class="nav-btn" onclick="refreshLibrary()">åˆ·æ–°</button>
            <button class="nav-btn btn-danger" onclick="clearAllCache()">æ¸…ç©ºæ‰€æœ‰ç¼“å­˜</button>
        </nav>
    </header>
    
    <div class="container">
        <div class="info-banner" style="background: #e3f2fd; color: #1565c0; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;">
            ğŸ’¡ <strong>ä½¿ç”¨æç¤º:</strong> 
            ç‚¹å‡»åŸŸåå³ä¾§çš„"å±•å¼€"æŒ‰é’®æŸ¥çœ‹ç¼“å­˜çš„é¡µé¢ï¼Œç‚¹å‡»URLå¯ç›´æ¥è·³è½¬ç¿»è¯‘é¡µé¢ã€‚
            æ”¯æŒå¿«æ·é”®ï¼š<kbd>Ctrl+R</kbd> åˆ·æ–°ï¼Œ<kbd>Esc</kbd> æ”¶èµ·æ‰€æœ‰å±•å¼€é¡¹ã€‚
        </div>
        
        <div id="loading" class="loading">æ­£åœ¨åŠ è½½åº“æ•°æ®...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="library-content"></div>
    </div>

    <script>
        let libraryData = [];
        
        async function loadLibrary() {
            try {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('error').style.display = 'none';
                
                const response = await fetch('/api/library');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                libraryData = data.domains;
                renderLibrary();
            } catch (error) {
                showError(`åŠ è½½å¤±è´¥: ${error.message}`);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        function renderLibrary() {
            const content = document.getElementById('library-content');
            if (libraryData.length === 0) {
                content.innerHTML = '<div class="loading">æš‚æ— ç¼“å­˜æ•°æ®</div>';
                return;
            }
            
            content.innerHTML = libraryData.map(domain => `
                <div class="domain-card">
                    <div class="domain-header">
                        <div>
                            <div class="domain-name">${domain.domain}</div>
                            <div class="domain-stats">
                                ${domain.cache_count} ä¸ªé¡µé¢ â€¢ ${formatBytes(domain.total_size_bytes)} â€¢ 
                                æœ€åæ›´æ–°: ${formatDate(domain.last_updated)}
                            </div>
                        </div>
                        <div class="domain-actions">
                            <button class="btn btn-info" onclick="toggleDomain('${domain.domain}')">
                                <span id="toggle-${domain.domain}">å±•å¼€</span>
                            </button>
                            <button class="btn btn-danger" onclick="deleteDomain('${domain.domain}')">åˆ é™¤</button>
                        </div>
                    </div>
                    <div class="url-list" id="urls-${domain.domain}">
                        ${domain.urls.map(url => `
                            <div class="url-item">
                                <div class="url-info" onclick="openUrl('${encodeURIComponent(url.url)}')">
                                    <div class="url-title">
                                        ${url.title || 'æ— æ ‡é¢˜'}
                                        <span class="cache-status ${getCacheStatus(url.expires_at)}">${getCacheStatusText(url.expires_at)}</span>
                                    </div>
                                    <a href="/website/${encodeURIComponent(url.url)}" class="url-link" target="_blank" onclick="event.stopPropagation()">
                                        ${truncateUrl(url.url, 60)}
                                    </a>
                                    <div class="url-meta">
                                        ${url.source_lang} â†’ ${url.target_lang} â€¢ 
                                        ${formatDate(url.created_at)} â€¢ ${formatBytes(url.size_bytes)}
                                        ${url.expires_at < Math.floor(Date.now() / 1000) ? ' â€¢ å·²è¿‡æœŸ' : ''}
                                    </div>
                                </div>
                                <div class="url-actions">
                                    <button class="btn btn-info" onclick="openUrl('${encodeURIComponent(url.url)}', event)" title="åœ¨æ–°æ ‡ç­¾é¡µä¸­ç¿»è¯‘">ç¿»è¯‘</button>
                                    <button class="btn btn-danger" onclick="deleteUrl('${escapeQuotes(url.url)}', '${url.source_lang}', '${url.target_lang}', event)" title="åˆ é™¤ç¼“å­˜">åˆ é™¤</button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        function toggleDomain(domain) {
            const urlList = document.getElementById(`urls-${domain}`);
            const toggleBtn = document.getElementById(`toggle-${domain}`);
            
            if (urlList.classList.contains('expanded')) {
                urlList.classList.remove('expanded');
                toggleBtn.textContent = 'å±•å¼€';
            } else {
                urlList.classList.add('expanded');
                toggleBtn.textContent = 'æ”¶èµ·';
            }
        }
        
        async function deleteDomain(domain) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤åŸŸå "${domain}" çš„æ‰€æœ‰ç¼“å­˜å—ï¼Ÿ`)) return;
            
            try {
                const response = await fetch('/api/library/action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'delete_domain', domain })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                if (result.success) {
                    await loadLibrary();
                } else {
                    showError(result.message);
                }
            } catch (error) {
                showError(`åˆ é™¤å¤±è´¥: ${error.message}`);
            }
        }
        
        function openUrl(encodedUrl, event) {
            if (event) {
                event.stopPropagation();
            }
            const websiteUrl = `/website/${encodedUrl}`;
            window.open(websiteUrl, '_blank');
        }
        
        function escapeQuotes(str) {
            return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }
        
        async function deleteUrl(url, sourceLang, targetLang, event) {
            if (event) {
                event.stopPropagation();
            }
            if (!confirm(`ç¡®å®šè¦åˆ é™¤è¿™ä¸ªé¡µé¢çš„ç¼“å­˜å—ï¼Ÿ`)) return;
            
            try {
                const response = await fetch('/api/library/action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        action: 'delete_url', 
                        url, 
                        source_lang: sourceLang, 
                        target_lang: targetLang 
                    })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                if (result.success) {
                    await loadLibrary();
                } else {
                    showError(result.message);
                }
            } catch (error) {
                showError(`åˆ é™¤å¤±è´¥: ${error.message}`);
            }
        }
        
        async function clearAllCache() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç¼“å­˜å—ï¼Ÿè¿™ä¸ªæ“ä½œä¸å¯æ¢å¤ï¼')) return;
            
            try {
                const response = await fetch('/api/cache/clear', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                if (result.success) {
                    await loadLibrary();
                } else {
                    showError(result.message);
                }
            } catch (error) {
                showError(`æ¸…ç©ºå¤±è´¥: ${error.message}`);
            }
        }
        
        function refreshLibrary() {
            loadLibrary();
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function formatDate(timestamp) {
            return new Date(timestamp * 1000).toLocaleString('zh-CN');
        }
        
        function getCacheStatus(expiresAt) {
            const now = Math.floor(Date.now() / 1000);
            const timeLeft = expiresAt - now;
            
            if (timeLeft <= 0) return 'expired';
            if (timeLeft <= 3600) return 'expiring'; // 1å°æ—¶å†…è¿‡æœŸ
            return 'fresh';
        }
        
        function getCacheStatusText(expiresAt) {
            const now = Math.floor(Date.now() / 1000);
            const timeLeft = expiresAt - now;
            
            if (timeLeft <= 0) return 'å·²è¿‡æœŸ';
            if (timeLeft <= 3600) return 'å³å°†è¿‡æœŸ';
            if (timeLeft <= 86400) return 'ä»Šæ—¥è¿‡æœŸ';
            return 'æœ‰æ•ˆ';
        }
        
        function truncateUrl(url, maxLength) {
            if (url.length <= maxLength) return url;
            const start = url.substring(0, maxLength - 3);
            return start + '...';
        }
        
        // é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', function(event) {
            // Ctrl/Cmd + R åˆ·æ–°åº“
            if ((event.ctrlKey || event.metaKey) && event.key === 'r') {
                event.preventDefault();
                refreshLibrary();
            }
            
            // Escape å…³é—­æ‰€æœ‰å±•å¼€çš„åŸŸå
            if (event.key === 'Escape') {
                document.querySelectorAll('.url-list.expanded').forEach(list => {
                    const domain = list.id.replace('urls-', '');
                    toggleDomain(domain);
                });
            }
        });
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', loadLibrary);
    </script>
</body>
</html>"#;
    
    Html(library_html.to_string())
}

/// è·å–åº“æ•°æ®å¤„ç†å™¨
#[cfg(feature = "web")]
async fn get_library_data(
    State(state): State<Arc<AppState>>,
) -> Result<Json<LibraryResponse>, (StatusCode, Json<serde_json::Value>)> {
    if let Some(ref cache) = state.redis_cache {
        match cache.get_domains_stats() {
            Ok(domain_stats) => {
                let mut domains = Vec::new();
                
                for (domain, (count, size, last_updated)) in domain_stats {
                    // è·å–è¯¥åŸŸåä¸‹çš„æ‰€æœ‰URL
                    let urls = match cache.get_by_domain(&domain) {
                        Ok(translations) => {
                            translations.into_iter().map(|t| LibraryUrl {
                                url: t.url,
                                title: t.title,
                                source_lang: t.source_lang,
                                target_lang: t.target_lang,
                                created_at: t.created_at,
                                expires_at: t.expires_at,
                                size_bytes: 0, // TODO: è®¡ç®—å®é™…å¤§å°
                            }).collect()
                        }
                        Err(_) => Vec::new(),
                    };
                    
                    domains.push(LibraryDomain {
                        domain,
                        cache_count: count,
                        total_size_bytes: size,
                        last_updated,
                        urls,
                    });
                }
                
                // æŒ‰ç¼“å­˜æ•°é‡æ’åº
                domains.sort_by(|a, b| b.cache_count.cmp(&a.cache_count));
                
                let response = LibraryResponse {
                    total_domains: domains.len(),
                    page: 1,
                    limit: 100,
                    domains,
                };
                
                Ok(Json(response))
            }
            Err(e) => {
                Err((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(serde_json::json!({
                        "error": true,
                        "message": format!("è·å–åº“æ•°æ®å¤±è´¥: {}", e)
                    }))
                ))
            }
        }
    } else {
        Ok(Json(LibraryResponse {
            domains: Vec::new(),
            total_domains: 0,
            page: 1,
            limit: 100,
        }))
    }
}

/// åº“æ“ä½œå¤„ç†å™¨
#[cfg(feature = "web")]
async fn library_action(
    State(state): State<Arc<AppState>>,
    ExtractJson(request): ExtractJson<LibraryActionRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<serde_json::Value>)> {
    if let Some(ref cache) = state.redis_cache {
        let result = match request.action.as_str() {
            "delete_domain" => {
                if let Some(domain) = request.domain {
                    cache.delete_domain(&domain)
                        .map(|count| format!("æˆåŠŸåˆ é™¤åŸŸå {} çš„ {} ä¸ªç¼“å­˜æ¡ç›®", domain, count))
                } else {
                    Err(redis::RedisError::from((redis::ErrorKind::TypeError, "Missing domain parameter")))
                }
            }
            "delete_url" => {
                if let (Some(url), Some(source_lang), Some(target_lang)) = 
                    (request.url, request.source_lang, request.target_lang) {
                    cache.delete(&url, &source_lang, &target_lang)
                        .map(|deleted| if deleted { 
                            "æˆåŠŸåˆ é™¤URLç¼“å­˜".to_string() 
                        } else { 
                            "URLç¼“å­˜ä¸å­˜åœ¨".to_string() 
                        })
                } else {
                    Err(redis::RedisError::from((redis::ErrorKind::TypeError, "Missing URL parameters")))
                }
            }
            "refresh_domain" => {
                // TODO: å®ç°åŸŸååˆ·æ–°åŠŸèƒ½
                Ok("åˆ·æ–°åŠŸèƒ½å¾…å®ç°".to_string())
            }
            _ => {
                Err(redis::RedisError::from((redis::ErrorKind::TypeError, "Unknown action")))
            }
        };
        
        match result {
            Ok(message) => {
                Ok(Json(serde_json::json!({
                    "success": true,
                    "message": message
                })))
            }
            Err(e) => {
                Err((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(serde_json::json!({
                        "error": true,
                        "message": format!("æ“ä½œå¤±è´¥: {}", e)
                    }))
                ))
            }
        }
    } else {
        Ok(Json(serde_json::json!({
            "success": false,
            "message": "ç¼“å­˜æœªå¯ç”¨"
        })))
    }
}

/// é web feature çš„å ä½å‡½æ•°
#[cfg(not(feature = "web"))]
async fn library_page() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

#[cfg(not(feature = "web"))]
async fn get_library_data() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}

#[cfg(not(feature = "web"))]
async fn library_action() -> Result<String, String> {
    Err("Web feature not enabled".to_string())
}